<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legislative Comment Widget</title>
    <style>
        /* Reddit-style variables */
        :root {
            --reddit-orange: #ff4500;
            --reddit-blue: #0079d3;
            --reddit-light-blue: #cce5f8;
            --reddit-dark-blue: #0060a8;
            --reddit-light-bg: #f6f7f8;
            --reddit-border: #ccc;
            --reddit-light-border: #edeff1;
            --reddit-text: #1c1c1c;
            --reddit-text-light: #7c7c7c;
            --reddit-bg-hover: #f6f7f8;
            --reddit-card-bg: #ffffff;
            --reddit-success: #46d160;
            --reddit-error: #ea0027;
        }
        
        /* Widget container */
        .comment-widget {
            max-width: 750px;
            margin: 20px auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--reddit-light-bg);
            padding: 20px;
            border-radius: 8px;
        }
        
        /* Widget header */
        .widget-header {
            background: var(--reddit-card-bg);
            border: 1px solid var(--reddit-border);
            border-radius: 4px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .widget-title {
            font-size: 18px;
            font-weight: 500;
            color: var(--reddit-text);
            margin: 0 0 8px 0;
        }
        
        .widget-subtitle {
            font-size: 14px;
            color: var(--reddit-text-light);
            margin: 0 0 12px 0;
        }
        
        .legislation-info {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--reddit-light-bg);
            border: 1px solid var(--reddit-light-border);
            border-radius: 20px;
            font-size: 12px;
        }
        
        .legislation-badge {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: var(--reddit-blue);
            border-radius: 50%;
        }
        
        .legislation-id {
            color: var(--reddit-text);
            font-weight: 500;
        }
        
        /* Comment form */
        .comment-form {
            background: var(--reddit-card-bg);
            border: 1px solid var(--reddit-border);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 16px;
            transition: box-shadow 0.2s ease;
        }
        
        .comment-form:focus-within {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Form header */
        .form-header {
            padding: 12px 16px;
            background: var(--reddit-light-bg);
            border-bottom: 1px solid var(--reddit-light-border);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            background: var(--reddit-blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }
        
        .commenting-as {
            font-size: 12px;
            color: var(--reddit-text-light);
        }
        
        .username {
            color: var(--reddit-blue);
            font-weight: 500;
        }
        
        /* Textarea container */
        .textarea-container {
            padding: 16px;
        }
        
        .comment-textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--reddit-light-border);
            border-radius: 4px;
            font-size: 14px;
            line-height: 21px;
            color: var(--reddit-text);
            resize: vertical;
            font-family: inherit;
            transition: border-color 0.2s ease;
        }
        
        .comment-textarea:focus {
            outline: none;
            border-color: var(--reddit-blue);
        }
        
        .comment-textarea::placeholder {
            color: var(--reddit-text-light);
        }
        
        /* Form footer */
        .form-footer {
            padding: 12px 16px;
            background: var(--reddit-light-bg);
            border-top: 1px solid var(--reddit-light-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .anonymous-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
            color: var(--reddit-text);
        }
        
        .anonymous-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .form-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .char-count {
            font-size: 12px;
            color: var(--reddit-text-light);
        }
        
        .char-count.warning {
            color: var(--reddit-orange);
        }
        
        .char-count.error {
            color: var(--reddit-error);
        }
        
        .submit-btn {
            background: var(--reddit-blue);
            color: white;
            border: none;
            padding: 8px 24px;
            border-radius: 9999px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
            min-width: 100px;
        }
        
        .submit-btn:hover:not(:disabled) {
            background: var(--reddit-dark-blue);
        }
        
        .submit-btn:disabled {
            background: var(--reddit-border);
            cursor: not-allowed;
        }
        
        .submit-btn.loading {
            color: transparent;
        }
        
        .submit-btn.loading::after {
            content: "";
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid white;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 16px 24px;
            border-radius: 4px;
            font-size: 14px;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        .notification.success {
            background: var(--reddit-success);
        }
        
        .notification.error {
            background: var(--reddit-error);
        }
        
        /* Comments section */
        .comments-section {
            background: var(--reddit-card-bg);
            border: 1px solid var(--reddit-border);
            border-radius: 4px;
            padding: 16px;
            min-height: 200px;
        }
        
        .comments-header {
            font-size: 14px;
            font-weight: 500;
            color: var(--reddit-text);
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--reddit-light-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comment-count {
            color: var(--reddit-text-light);
            font-size: 12px;
            font-weight: normal;
        }
        
        /* Individual comment styles */
        .comment-item {
            padding: 16px 0;
            border-bottom: 1px solid var(--reddit-light-border);
        }
        
        .comment-item:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .comment-header-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .comment-avatar {
            width: 24px;
            height: 24px;
            background: var(--reddit-blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .comment-avatar.anonymous {
            background: var(--reddit-text-light);
        }
        
        .comment-author {
            font-size: 12px;
            font-weight: 500;
            color: var(--reddit-text);
        }
        
        .comment-author.anonymous {
            color: var(--reddit-text-light);
        }
        
        .comment-time {
            font-size: 12px;
            color: var(--reddit-text-light);
        }
        
        .comment-text {
            font-size: 14px;
            line-height: 21px;
            color: var(--reddit-text);
            margin-left: 32px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .comment-actions {
            margin-left: 32px;
            margin-top: 8px;
            display: flex;
            gap: 16px;
        }
        
        .vote-button {
            display: flex;
            align-items: center;
            gap: 4px;
            background: none;
            border: none;
            color: var(--reddit-text-light);
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .vote-button:hover {
            background: var(--reddit-light-bg);
        }
        
        .vote-button:disabled {
            cursor: wait;
            opacity: 0.5;
        }
        
        .vote-button.upvoted {
            color: var(--reddit-orange);
            background: rgba(255, 69, 0, 0.1);
        }
        
        .vote-button.downvoted {
            color: var(--reddit-blue);
            background: rgba(0, 121, 211, 0.1);
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--reddit-text-light);
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        /* Loading spinner */
        .loading-spinner {
            text-align: center;
            padding: 40px;
        }
        
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 3px solid var(--reddit-light-border);
            border-top-color: var(--reddit-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        /* Debug info */
        .debug-info {
            margin-top: 12px;
            padding: 12px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            font-size: 12px;
            color: #856404;
            font-family: monospace;
        }
        
        /* Mobile responsive */
        @media (max-width: 640px) {
            .comment-widget {
                padding: 12px;
            }
            
            .form-footer {
                flex-wrap: wrap;
                gap: 12px;
            }
            
            .form-actions {
                width: 100%;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div class="comment-widget">
        <!-- Widget Header -->
        <div class="widget-header">
            <h2 class="widget-title">💬 Community Discussion</h2>
            <p class="widget-subtitle">Share your thoughts on this legislation</p>
            <div class="legislation-info">
                <span class="legislation-badge"></span>
                <span>Discussing: <span class="legislation-id" id="legislation-display">Loading...</span></span>
            </div>
        </div>
        
        <!-- Comment Form -->
        <div class="comment-form">
            <div class="form-header">
                <div class="user-avatar" id="user-avatar">?</div>
                <div>
                    <div class="commenting-as">Comment as</div>
                    <div class="username" id="username-display">Anonymous</div>
                </div>
            </div>
            
            <div class="textarea-container">
                <textarea 
                    class="comment-textarea" 
                    id="comment-input"
                    placeholder="What are your thoughts?"
                    maxlength="1000"
                ></textarea>
            </div>
            
            <div class="form-footer">
                <label class="anonymous-toggle">
                    <input type="checkbox" id="anonymous-checkbox">
                    <span>Post anonymously</span>
                </label>
                
                <div class="form-actions">
                    <span class="char-count" id="char-count">1000</span>
                    <button class="submit-btn" id="submit-btn">Comment</button>
                </div>
            </div>
        </div>
        
        <!-- Comments Display -->
        <div class="comments-section">
            <div class="comments-header">
                <span>Recent Comments</span>
                <span class="comment-count" id="comment-count">0 comments</span>
            </div>
            <div id="comments-container">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        
        <!-- Debug Info (remove in production) -->
        <div class="debug-info" id="debug-info"></div>
    </div>
    
    <!-- Notification Container -->
    <div class="notification" id="notification"></div>
    
    <script>
        // Configuration
        const API_BASE = 'https://xvkq-pq7i-idtl.n7d.xano.io/api:Hj4C6PGO';
        const DEBUG = true; // Set to false in production
        
        // Store user's votes
        let userVotes = {};
        
        // Get legislation ID from URL
        function getLegislationId() {
            const urlParams = new URLSearchParams(window.location.search);
            const recordId = urlParams.get('recordId');
            return recordId || 'orphaned :(';
        }
        
        // Initialize widget
        document.addEventListener('DOMContentLoaded', function() {
            const legislationId = getLegislationId();
            const userEmail = localStorage.getItem('userEmail') || '';
            const sessionId = getOrCreateSessionId();
            
            // Display legislation ID
            document.getElementById('legislation-display').textContent = legislationId;
            
            // Set user display
            updateUserDisplay(userEmail);
            
            // Add email input handler
            const usernameDisplay = document.getElementById('username-display');
            usernameDisplay.style.cursor = 'pointer';
            usernameDisplay.title = userEmail ? 'Click to change email' : 'Click to set your email';
            usernameDisplay.addEventListener('click', function() {
                const currentEmail = localStorage.getItem('userEmail') || '';
                const email = prompt('Enter your email (leave empty to post anonymously):', currentEmail);
                if (email !== null) { // User didn't cancel
                    if (email) {
                        localStorage.setItem('userEmail', email);
                    } else {
                        localStorage.removeItem('userEmail');
                    }
                    updateUserDisplay(email);
                }
            });
            
            // Debug info
            if (DEBUG) {
                const debugInfo = document.getElementById('debug-info');
                debugInfo.innerHTML = `
                    <strong>Debug Info:</strong><br>
                    Legislation ID: ${legislationId}<br>
                    Session ID: ${sessionId}<br>
                    User Email: ${userEmail || 'Not set (click username to set)'}<br>
                    API Endpoints:<br>
                    - Comments: ${API_BASE}/comment<br>
                    - Votes: ${API_BASE}/comment_vote<br>
                    <br>
                    <strong>Vote Payload:</strong><br>
                    - comment_id: [comment's ID] <span style="color: red">*Must not be 0!</span><br>
                    - user_identifier: ${userEmail || sessionId}<br>
                    - vote_type: upvote/downvote<br>
                    - matterId: ${legislationId}<br>
                    <br>
                    <em>Check console for detailed API responses</em>
                `;
            } else {
                document.getElementById('debug-info').style.display = 'none';
            }
            
            // Set up event listeners
            setupEventListeners();
            
            // Load user votes and comments
            loadUserVotes().then(() => {
                loadComments();
            });
            
            // Auto-refresh comments every 30 seconds
            setInterval(() => {
                loadUserVotes().then(() => {
                    loadComments(true);
                });
            }, 30000);
        });
        
        // Get or create session ID for anonymous users
        function getOrCreateSessionId() {
            let sessionId = localStorage.getItem('sessionId');
            if (!sessionId) {
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('sessionId', sessionId);
            }
            return sessionId;
        }
        
        // Update user display
        function updateUserDisplay(email) {
            const avatar = document.getElementById('user-avatar');
            const usernameDisplay = document.getElementById('username-display');
            const anonymousCheckbox = document.getElementById('anonymous-checkbox');
            
            if (email) {
                avatar.textContent = email[0].toUpperCase();
                avatar.style.background = 'var(--reddit-blue)';
                usernameDisplay.textContent = email;
                anonymousCheckbox.checked = false;
                anonymousCheckbox.disabled = false;
            } else {
                avatar.textContent = '?';
                avatar.style.background = 'var(--reddit-text-light)';
                usernameDisplay.textContent = 'Anonymous';
                anonymousCheckbox.checked = true;
                anonymousCheckbox.disabled = true;
            }
        }
        
        // Set up event listeners
        function setupEventListeners() {
            const textarea = document.getElementById('comment-input');
            const charCount = document.getElementById('char-count');
            const submitBtn = document.getElementById('submit-btn');
            const anonymousCheckbox = document.getElementById('anonymous-checkbox');
            
            // Character counter
            textarea.addEventListener('input', function() {
                const remaining = 1000 - this.value.length;
                charCount.textContent = remaining;
                
                charCount.classList.remove('warning', 'error');
                if (remaining < 100) {
                    charCount.classList.add('warning');
                }
                if (remaining < 20) {
                    charCount.classList.add('error');
                }
            });
            
            // Submit comment
            submitBtn.addEventListener('click', submitComment);
            
            // Enter to submit (with Ctrl/Cmd)
            textarea.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    submitComment();
                }
            });
            
            // Anonymous checkbox
            anonymousCheckbox.addEventListener('change', function() {
                const usernameDisplay = document.getElementById('username-display');
                if (this.checked) {
                    usernameDisplay.textContent = 'Anonymous';
                } else {
                    const email = localStorage.getItem('userEmail') || 'Anonymous';
                    usernameDisplay.textContent = email;
                }
            });
            
            // Vote button clicks (delegated)
            document.addEventListener('click', async function(e) {
                if (e.target.classList.contains('vote-button')) {
                    e.preventDefault();
                    const button = e.target;
                    const commentIdStr = button.dataset.commentId;
                    const commentId = parseInt(commentIdStr);
                    const isUpvote = button.classList.contains('upvote');
                    const voteType = isUpvote ? 'upvote' : 'downvote';
                    
                    if (DEBUG) {
                        console.log('Vote button clicked:', {
                            commentIdStr: commentIdStr,
                            commentId: commentId,
                            voteType: voteType,
                            buttonElement: button
                        });
                    }
                    
                    // Make sure we have a valid comment ID
                    if (!commentId || isNaN(commentId) || commentId === 0) {
                        console.error('Invalid comment ID:', commentIdStr);
                        showNotification('Error: Invalid comment ID', 'error');
                        return;
                    }
                    
                    // Disable button during request
                    button.disabled = true;
                    button.style.opacity = '0.5';
                    
                    await handleVote(commentId, voteType);
                    
                    // Re-enable button
                    button.disabled = false;
                    button.style.opacity = '1';
                }
            });
        }
        
        // Submit comment
        async function submitComment() {
            const textarea = document.getElementById('comment-input');
            const submitBtn = document.getElementById('submit-btn');
            const anonymousCheckbox = document.getElementById('anonymous-checkbox');
            
            const commentText = textarea.value.trim();
            if (!commentText) {
                showNotification('Please enter a comment', 'error');
                return;
            }
            
            // Disable form
            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            textarea.disabled = true;
            
            // Prepare data
            const data = {
                legislation_id: getLegislationId(),
                comment_text: commentText,
                user_email: anonymousCheckbox.checked ? null : localStorage.getItem('userEmail'),
                is_anonymous: anonymousCheckbox.checked,
                session_id: getOrCreateSessionId(),
                ip_address: 'client-ip' // This would be set by your backend
            };
            
            try {
                const response = await fetch(`${API_BASE}/comment`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (DEBUG) {
                    console.log('Comment creation response:', result);
                }
                
                // Success
                showNotification('Comment posted successfully!', 'success');
                textarea.value = '';
                document.getElementById('char-count').textContent = '1000';
                
                // Add the new comment to the display immediately
                const newComment = {
                    id: result.id || result.comment_id || Date.now(), // Handle different response formats
                    ...data,
                    created_at: result.created_at || new Date().toISOString(),
                    upvotes: 0,
                    downvotes: 0
                };
                
                if (DEBUG) {
                    console.log('New comment object:', newComment);
                }
                
                // Prepend new comment to the list
                const container = document.getElementById('comments-container');
                const emptyState = container.querySelector('.empty-state');
                if (emptyState) {
                    container.innerHTML = '';
                }
                
                const newCommentHtml = renderComment(newComment);
                container.insertAdjacentHTML('afterbegin', newCommentHtml);
                
                // Update count
                const countElement = document.getElementById('comment-count');
                const currentCount = parseInt(countElement.textContent) || 0;
                countElement.textContent = `${currentCount + 1} comment${currentCount + 1 !== 1 ? 's' : ''}`;
                
                // Full reload after a delay to sync with server
                setTimeout(() => {
                    loadUserVotes().then(() => {
                        loadComments(true);
                    });
                }, 2000);
                
            } catch (error) {
                console.error('Error posting comment:', error);
                showNotification('Failed to post comment. Please try again.', 'error');
            } finally {
                // Re-enable form
                submitBtn.disabled = false;
                submitBtn.classList.remove('loading');
                textarea.disabled = false;
                textarea.focus();
            }
        }
        
        // Load user's votes
        async function loadUserVotes() {
            try {
                const response = await fetch(`${API_BASE}/comment_vote`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const votes = await response.json();
                    const userIdentifier = localStorage.getItem('userEmail') || getOrCreateSessionId();
                    
                    if (DEBUG) {
                        console.log('All votes from API:', votes);
                        console.log('Current user identifier:', userIdentifier);
                    }
                    
                    // Build a map of comment_id -> vote_type for current user
                    userVotes = {};
                    let userVoteCount = 0;
                    
                    votes.forEach(vote => {
                        // Only process votes with valid comment_id (not 0)
                        if (vote.user_identifier === userIdentifier && vote.comment_id && vote.comment_id !== 0) {
                            const commentId = parseInt(vote.comment_id);
                            userVotes[commentId] = vote.vote_type;
                            userVoteCount++;
                        }
                    });
                    
                    if (DEBUG) {
                        console.log('User votes loaded:', userVotes);
                        console.log('Total votes in database:', votes.length);
                        console.log('Votes by current user:', userVoteCount);
                        console.log('Votes with invalid comment_id (0):', votes.filter(v => !v.comment_id || v.comment_id === 0).length);
                    }
                }
            } catch (error) {
                console.error('Error loading user votes:', error);
            }
        }
        
        // Handle vote action
        async function handleVote(commentId, voteType) {
            const userIdentifier = localStorage.getItem('userEmail') || getOrCreateSessionId();
            const legislationId = getLegislationId();
            
            if (DEBUG) {
                console.log('Submitting vote:', {
                    comment_id: commentId,
                    user_identifier: userIdentifier,
                    vote_type: voteType,
                    matterId: legislationId  // Fixed: capital I in matterId
                });
            }
            
            try {
                const response = await fetch(`${API_BASE}/comment_vote`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        comment_id: commentId,
                        user_identifier: userIdentifier,
                        vote_type: voteType,
                        matterId: legislationId  // Fixed: capital I in matterId
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (DEBUG) {
                        console.log('Vote response:', result);
                    }
                    
                    // Update local vote state based on what actually happened
                    // Reload votes to get the truth from the server
                    await loadUserVotes();
                    
                    // Determine what happened based on the updated state
                    const newVoteState = userVotes[commentId];
                    
                    if (!newVoteState && existingVote) {
                        // Vote was removed
                        showNotification('Vote removed', 'success');
                    } else if (newVoteState) {
                        // Vote was added or changed
                        showNotification(
                            newVoteState === 'upvote' ? 'Upvoted!' : 'Downvoted!',
                            'success'
                        );
                    }
                    
                    // Reload votes and comments to sync
                    await loadUserVotes();
                    await loadComments(true);
                } else {
                    const errorText = await response.text();
                    console.error('Vote failed:', response.status, errorText);
                    showNotification('Failed to register vote', 'error');
                }
            } catch (error) {
                console.error('Error voting:', error);
                showNotification('Failed to register vote', 'error');
            }
        }
        
        // Load comments from GET endpoint with client-side filtering
        async function loadComments(isAutoRefresh = false) {
            const container = document.getElementById('comments-container');
            const countElement = document.getElementById('comment-count');
            const legislationId = getLegislationId();
            
            try {
                // Show loading state only for initial load
                if (!isAutoRefresh) {
                    container.innerHTML = '<div class="loading-spinner"><div class="spinner"></div></div>';
                } else {
                    // Show subtle refresh indicator
                    countElement.innerHTML += ' <span style="font-size: 10px;">🔄</span>';
                }
                
                // Fetch all comments
                const response = await fetch(`${API_BASE}/comment`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const responseData = await response.json();
                
                // Handle different response formats (array vs object with data property)
                const allComments = Array.isArray(responseData) ? responseData : (responseData.data || responseData.comments || []);
                
                if (DEBUG) {
                    console.log('Comments API response:', responseData);
                    console.log('All comments fetched:', allComments.length);
                    if (allComments.length > 0) {
                        console.log('Sample comment structure:', allComments[0]);
                    }
                }
                
                // Filter comments for this legislation (client-side)
                const filteredComments = allComments.filter(comment => 
                    comment.legislation_id === legislationId
                );
                
                if (DEBUG) {
                    console.log(`Filtered comments for legislation ${legislationId}:`, filteredComments.length);
                }
                
                // Sort by newest first
                filteredComments.sort((a, b) => 
                    new Date(b.created_at) - new Date(a.created_at)
                );
                
                // Update count
                countElement.textContent = `${filteredComments.length} comment${filteredComments.length !== 1 ? 's' : ''}`;
                
                // Display comments
                if (filteredComments.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">💬</div>
                            <div>No comments yet. Be the first to share your thoughts!</div>
                        </div>
                    `;
                } else {
                    container.innerHTML = filteredComments.map(comment => renderComment(comment)).join('');
                }
                
            } catch (error) {
                console.error('Error loading comments:', error);
                if (!isAutoRefresh) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">⚠️</div>
                            <div>Failed to load comments. Please try again later.</div>
                        </div>
                    `;
                }
            }
        }
        
        // Render a single comment
        function renderComment(comment) {
            const isAnonymous = comment.is_anonymous || !comment.user_email;
            const displayName = isAnonymous ? 'Anonymous' : comment.user_email;
            const initial = isAnonymous ? '?' : displayName[0].toUpperCase();
            const timeAgo = formatTimeAgo(comment.created_at);
            const commentId = parseInt(comment.id) || parseInt(comment.comment_id) || 0;
            
            if (DEBUG && commentId === 0) {
                console.warn('Comment has no valid ID:', comment);
            }
            
            // Check user's vote on this comment
            const userVote = userVotes[commentId];
            const upvoteClass = userVote === 'upvote' ? 'upvoted' : '';
            const downvoteClass = userVote === 'downvote' ? 'downvoted' : '';
            
            return `
                <div class="comment-item" data-comment-id="${commentId}">
                    <div class="comment-header-info">
                        <div class="comment-avatar ${isAnonymous ? 'anonymous' : ''}">${initial}</div>
                        <span class="comment-author ${isAnonymous ? 'anonymous' : ''}">${displayName}</span>
                        <span class="comment-time">• ${timeAgo}</span>
                        ${DEBUG ? `<span style="font-size: 10px; color: #999;"> (ID: ${commentId})</span>` : ''}
                    </div>
                    <div class="comment-text">${escapeHtml(comment.comment_text)}</div>
                    <div class="comment-actions">
                        <button class="vote-button upvote ${upvoteClass}" data-comment-id="${commentId}">
                            ⬆ ${comment.upvotes || 0}
                        </button>
                        <button class="vote-button downvote ${downvoteClass}" data-comment-id="${commentId}">
                            ⬇ ${comment.downvotes || 0}
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Format time ago
        function formatTimeAgo(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);
            
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            if (days < 30) return `${days}d ago`;
            const months = Math.floor(days / 30);
            if (months < 12) return `${months}mo ago`;
            const years = Math.floor(months / 12);
            return `${years}y ago`;
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
    </script>
</body>
</html>
